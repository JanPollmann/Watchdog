= Java (repeated) function call support
Jan Pollmann <pollmannjanf@gmail.com>
:compat-mode!:
:url-org: https://github.com/JanPollmann
:url-repo: {url-org}/Watchdog
:url-rel-file-base: link:
:url-rel-tree-base: link:
ifdef::env-github[]
:url-rel-file-base: {url-repo}/blob/HEAD/
:url-rel-tree-base: {url-repo}/tree/HEAD/
endif::[]
:path-example-1-FastLoopApp: Tester/src/main/java/de/pollmann/watchdog/tester/app/FastLoopApp.java
:path-example-1-AppContext: Tester/src/main/java/de/pollmann/watchdog/tester/app/AppContext.java
:path-test: Library/src/test/java/de/pollmann/watchdog/
:path-test-sabotage: Library/src/test/java/de/pollmann/watchdog/SabotageTest.java

Each function call has a timeout and terminates the execution. After each function call (even after a timeout or an exception) a `TaskResult` is created with on of the following `ResultCode`:

* `ResultCode.OK` The execution is completed without exception and the result can be obtained with `TaskResult#getResult`
* `ResultCode.TIMEOUT` The function call was *NOT* completed, the task was canceled
* ResultCode.ERROR` An unexpected exception has occurred. The exception can be determined with `TaskResult#getErrorReason`.

== Quick start
[CAUTION]
====
still under construction! The API might still change a bit (hopefully it will become even better!).

In case of bugs, please create an issue. Gladly also together with a small example.
====
This library supports `Runnable`, `Callable`, `Consumer` and `Function`. When a timeout occurs, the worker thread is `interrupted`. Be careful to handle the interruption properly, otherwise a thread of an `ExecutorService` (=> your function) could end up in an infinite loop (=> examples). One way to handle an interruption is as follows:
[source, java]
----
if (Thread.interrupted()) {
  throw new InterruptedException();
}
----

=== How to
TODO publishing (maven?)

=== Setup
1. Import the `Library` in your project
2. Create & store a `WatchdogFactory`. Each factory stores two `ExecutorServices`
3. Use `Watchable.builder(...)` to create a watchable
4. Create an asynchronous function call with `WatchdogFactory#submitFunctionCall`, a synchronized function call using `WatchdogFactory#waitForCompletion` or create a `RepeatableTask` with `WatchdogFactory#createRepeated`
5. In case of a RepeatableTask call the task with `RepeatableTask#submitFunctionCall` and `RepeatableTask#waitForCompletion`

=== Important
[CAUTION]
====
* As soon as the internal worker of the `WatchdogFactory` gets garbage collected, `ExecutorServices#shutdown` is called for every `ExecutorServices` (finalize)
** a `RepeatableTask` has a reference to the internal worker
** to terminate the RepeatableTask call `RepeatableTask#terminate`
** a terminated RepeatableTask will throw a `RepeatableTaskTerminatedException`!
* The timeout is specified in milliseconds
** a timeout of 0 ms will be handled as `no timeout`
* For not repeated function calls, the input of a function/consumer is passed in the constructor!
====

== Example
Just implement `loop`. Remarks:

* A timeout of 0 ms will be handled as `no timeout`
* both tasks have a `ResultConsumer` registered, but that's an optional feature

ifdef::env-github[]
{url-rel-file-base}{path-example-1-FastLoopApp}
endif::[]
ifndef::env-github[]
[source, java]
----
include::{path-example-1-FastLoopApp}[]
----
endif::[]

terminate endless loop
ifdef::env-github[]
{url-rel-file-base}{path-test-sabotage}
endif::[]
ifndef::env-github[]
[source, java]
----
include::{path-test-sabotage}[]
----
endif::[]

You can find more examples in the UnitTests: +
ifdef::env-github[]
{url-rel-file-base}{path-test}
endif::[]
ifndef::env-github[]
{path-test}
endif::[]
